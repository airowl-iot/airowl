#include <Arduino.h>
#if defined(ARDUINO_M5STACK_Core2)
#include <M5Core2.h>
#endif
#if defined(ARDUINO_M5STACK_CORES3)
// #include <M5CoreS3.h>  // no touch support yet
#include <M5Unified.h>
#endif
#include <esp_task_wdt.h>
#include <WiFiManager.h> 
#include <WiFiManagerTz.h>
#include "Sensor.h"
#include "ui/lv_setup.h"
#include "ui/ui.h"
#include "config.h"
#include "time_func.h"
#include <FS.h>


#define WDT_TIMEOUT 60

WiFiManager wm;
TaskHandle_t myTaskHandle;

void on_time_available(struct timeval *t)
{
  Serial.println("Received time adjustment from NTP");
  struct tm timeInfo;
  getLocalTime(&timeInfo, 1000);
  Serial.println(&timeInfo, "%A, %B %d %Y %H:%M:%S zone %Z %z ");
  M5.Rtc.setDateTime( &timeInfo );
}

void setup() {
  M5.begin();
  lv_begin();  // Initialize LVGL for the Core2 screen
  ui_init();   // Initialize UI generated by Square Line
  M5.Display.setRotation(3);
  if(M5.Rtc.isEnabled())
  {
    M5.Log.println("RTC Enabled");
  }
  // Initialize the Task Watchdog Timer
  esp_task_wdt_init(WDT_TIMEOUT, true); // Enable panic so ESP32 restarts
  // Add the current task to the watchdog (loopTask)
  esp_task_wdt_add(NULL); // NULL means current task
  String mac = WiFi.macAddress();
  mac.replace(":", "");
  String apName = "AIROWL_" + mac.substring(6);
  xTaskCreatePinnedToCore(sensorData, "sensorData", 10000, NULL, 2, &myTaskHandle, 1);
  WiFiManagerNS::NTP::onTimeAvailable( &on_time_available );
  WiFiManagerNS::init( &wm, nullptr );
  std::vector<const char *> menu = {"wifi", "info", "custom", "param", "sep", "restart", "exit"};
  wm.setMenu(menu);
  wm.setConfigPortalBlocking(false);
  wm.setTitle("AIROWL Configuration");
  wm.autoConnect(apName.c_str(), "12345678");
  lv_label_set_text(ui_devicename, apName.c_str());
  time_init(); // Initialize time and date from compiler
  // Add the new task to the watchdog
  esp_task_wdt_add(myTaskHandle);
}

void loop() {  
  wm.process();
  lv_handler();  // Update UI
  update_time(); // Update time and date on UI
  // Reset the watchdog timer
  esp_task_wdt_reset();
}